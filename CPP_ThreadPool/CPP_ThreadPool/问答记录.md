# 线程池问答记录

## 问题1：为什么将 unique_ptr<MyTask> 改为每次循环创建新的 shared_ptr<MyTask>？

**问题代码位置：** `/home/ljcman/ProcessPool_to_ThreadPool/CPP_ThreadPool/CPP_ThreadPool/BO_threadPool/testThreadPool.cpp#L39-50`

### 原始代码的问题

原始代码中使用了一个 `unique_ptr<MyTask>` 对象：

```cpp
void test0()
{
    unique_ptr<MyTask> ptask(new MyTask());  // 只创建一个对象
    ThreadPool pool(5,10);
    pool.start();

    int count = 20;
    while(count--)
    {
        // 所有任务都使用同一个 ptask.get() 指针
        pool.addTask(bind(&MyTask::process, ptask.get(), 100));
    }
    
    pool.stop();
}
```

### 问题分析

1. **对象生命周期问题**：
   - 只创建了一个 `MyTask` 对象
   - 所有20个任务都绑定到同一个对象的 `process` 方法
   - 当 `test0()` 函数结束时，`unique_ptr` 会自动销毁 `MyTask` 对象
   - 但此时可能还有工作线程正在执行或准备执行绑定到该对象的任务
   - 这会导致访问已销毁对象的悬空指针问题

2. **竞态条件**：
   - 多个线程可能同时访问同一个 `MyTask` 对象
   - 虽然 `process` 方法本身可能是线程安全的，但共享同一个对象实例不是好的设计

### 修复后的代码

```cpp
void test0()
{
    ThreadPool pool(5,10);
    pool.start();

    int count = 20;
    while(count--)
    {
        // 为每个任务创建新的MyTask对象
        // 使用shared_ptr确保对象在任务执行期间不会被销毁
        auto ptask = std::make_shared<MyTask>();
        
        pool.addTask(bind(&MyTask::process, ptask.get(), 100));
    }
    
    pool.stop();
}
```

### 修复的优势

1. **解决生命周期问题**：
   - 每个任务都有自己独立的 `MyTask` 对象
   - `shared_ptr` 确保对象在所有引用它的任务执行完毕前不会被销毁
   - 即使 `test0()` 函数结束，对象仍然存在直到最后一个任务完成

2. **线程安全**：
   - 每个任务操作不同的对象实例，避免了竞态条件
   - 不需要额外的同步机制来保护对象状态

3. **更好的设计**：
   - 符合"一个任务一个对象"的设计原则
   - 更容易扩展（比如给每个任务传递不同的参数）

### 为什么选择 shared_ptr 而不是 unique_ptr？

- `bind` 创建的函数对象需要持有对 `MyTask` 对象的引用
- 任务可能在不同的线程中执行，需要共享所有权
- `shared_ptr` 提供了自动的引用计数，确保对象在所有任务完成前不会被销毁
- `unique_ptr` 无法在多个 `bind` 对象之间共享所有权

### 总结

这个修改解决了原始代码中的对象生命周期管理问题，确保了线程安全，并提供了更好的设计模式。这是多线程编程中的一个重要实践：确保共享资源的生命周期管理正确。

---

## 问题2：pool.stop()执行的时候，是否可能有些task还没执行完？

**问题代码位置：** `/home/ljcman/ProcessPool_to_ThreadPool/CPP_ThreadPool/CPP_ThreadPool/BO_threadPool/testThreadPool.cpp#L39-52`

### 答案：不会，ThreadPool::stop()方法确保所有任务都执行完毕

### ThreadPool::stop()方法的实现分析

```cpp
void ThreadPool::stop() {
    //如果任务队列不为空，就让主线程睡眠
    while(!m_taskQue.empty())
    {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    //标志位设为true，表示线程池要退出了
    m_isExit = true;

    //回收子线程之前应该唤醒所有阻塞的子线程
    m_taskQue.wakeup();

    //让主线程等待子线程的退出
    for(auto & th : m_threads)
    {
        th.join();
    }
}
```

### 执行流程详解

#### 第一阶段：等待任务队列清空
```cpp
while(!m_taskQue.empty())
{
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
```
- **目的**：确保任务队列中的所有任务都被工作线程取走
- **机制**：主线程每秒检查一次任务队列是否为空
- **保证**：只有当队列完全清空时才会继续执行

#### 第二阶段：设置退出标志
```cpp
m_isExit = true;
```
- **目的**：通知所有工作线程准备退出
- **作用**：工作线程在doTask()循环中会检查这个标志

#### 第三阶段：唤醒阻塞的线程
```cpp
m_taskQue.wakeup();
```
- **目的**：唤醒所有在等待新任务的工作线程
- **机制**：设置TaskQueue的m_flag为false，并notify_all()
- **结果**：阻塞在TaskQueue::pop()中的线程会被唤醒并返回空任务

#### 第四阶段：等待所有线程结束
```cpp
for(auto & th : m_threads)
{
    th.join();
}
```
- **目的**：确保所有工作线程都完全退出
- **机制**：主线程会阻塞等待每个工作线程执行完毕
- **保证**：只有当所有线程都退出后，stop()方法才会返回

### 工作线程的退出机制

在doTask()方法中：
```cpp
void ThreadPool::doTask() {
    while(!m_isExit)
    {
        ElemType task = getTask();
        if(task)
        {
            task();  // 执行任务
        }
        else
        {
            if(m_isExit) {
                break;  // 退出循环
            }
        }
    }
}
```

### 安全性保证

1. **任务队列清空保证**：
   - 第一阶段确保所有已提交的任务都被工作线程取走
   - 不会有任务遗留在队列中

2. **正在执行的任务完成保证**：
   - 工作线程会继续执行已经取到的任务
   - 只有在当前任务执行完毕后才会检查退出条件
   - `th.join()`确保线程完全结束

3. **优雅关闭**：
   - 不会强制终止正在执行的任务
   - 所有资源都会被正确清理

### 潜在的改进点

虽然当前实现是安全的，但有一个小的时间窗口问题：
- 在队列清空和设置m_isExit之间，理论上可能有新任务被添加
- 在实际使用中，应该在调用stop()之前停止添加新任务

### 总结

**pool.stop()方法通过四个阶段确保所有任务都执行完毕：**
1. 等待任务队列清空
2. 设置退出标志
3. 唤醒阻塞线程
4. 等待所有线程退出

**因此，当stop()方法返回时，可以确保：**
- 所有提交的任务都已执行完毕
- 所有工作线程都已安全退出
- 没有任务会被遗漏或中断