# 线程池问答记录

## 问题1：为什么将 unique_ptr<MyTask> 改为每次循环创建新的 shared_ptr<MyTask>？

**问题代码位置：** `/home/ljcman/ProcessPool_to_ThreadPool/CPP_ThreadPool/CPP_ThreadPool/BO_threadPool/testThreadPool.cpp#L39-50`

### 原始代码的问题

原始代码中使用了一个 `unique_ptr<MyTask>` 对象：

```cpp
void test0()
{
    unique_ptr<MyTask> ptask(new MyTask());  // 只创建一个对象
    ThreadPool pool(5,10);
    pool.start();

    int count = 20;
    while(count--)
    {
        // 所有任务都使用同一个 ptask.get() 指针
        pool.addTask(bind(&MyTask::process, ptask.get(), 100));
    }
    
    pool.stop();
}
```

### 问题分析

1. **对象生命周期问题**：
   - 只创建了一个 `MyTask` 对象
   - 所有20个任务都绑定到同一个对象的 `process` 方法
   - 当 `test0()` 函数结束时，`unique_ptr` 会自动销毁 `MyTask` 对象
   - 但此时可能还有工作线程正在执行或准备执行绑定到该对象的任务
   - 这会导致访问已销毁对象的悬空指针问题

2. **竞态条件**：
   - 多个线程可能同时访问同一个 `MyTask` 对象
   - 虽然 `process` 方法本身可能是线程安全的，但共享同一个对象实例不是好的设计

### 修复后的代码

```cpp
void test0()
{
    ThreadPool pool(5,10);
    pool.start();

    int count = 20;
    while(count--)
    {
        // 为每个任务创建新的MyTask对象
        // 使用shared_ptr确保对象在任务执行期间不会被销毁
        auto ptask = std::make_shared<MyTask>();
        
        pool.addTask(bind(&MyTask::process, ptask.get(), 100));
    }
    
    pool.stop();
}
```

### 修复的优势

1. **解决生命周期问题**：
   - 每个任务都有自己独立的 `MyTask` 对象
   - `shared_ptr` 确保对象在所有引用它的任务执行完毕前不会被销毁
   - 即使 `test0()` 函数结束，对象仍然存在直到最后一个任务完成

2. **线程安全**：
   - 每个任务操作不同的对象实例，避免了竞态条件
   - 不需要额外的同步机制来保护对象状态

3. **更好的设计**：
   - 符合"一个任务一个对象"的设计原则
   - 更容易扩展（比如给每个任务传递不同的参数）

### 为什么选择 shared_ptr 而不是 unique_ptr？

- `bind` 创建的函数对象需要持有对 `MyTask` 对象的引用
- 任务可能在不同的线程中执行，需要共享所有权
- `shared_ptr` 提供了自动的引用计数，确保对象在所有任务完成前不会被销毁
- `unique_ptr` 无法在多个 `bind` 对象之间共享所有权

### 总结

这个修改解决了原始代码中的对象生命周期管理问题，确保了线程安全，并提供了更好的设计模式。这是多线程编程中的一个重要实践：确保共享资源的生命周期管理正确。